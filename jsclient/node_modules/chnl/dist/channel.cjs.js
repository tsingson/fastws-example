/* chnl v1.0.0 by Vitaliy Potapov */
'use strict';

const innerEvents = [
  'onListenerAdded',
  'onListenerRemoved',
  'onFirstListenerAdded',
  'onLastListenerRemoved'
];

/**
 * Channel of particular events. Allows attach/detach listeners and dispatch event data.
 *
 * @param {String} [name]
 * @param {Boolean} [noInnerEvents]
 *
 * @example
 * import Channel from 'chnl';
 *
 * // create channel
 * const onMyEvent = new Channel();
 * // listen
 * onMyEvent.addListener(data => console.log(data));
 * // dispatch data
 * onMyEvent.dispatch(data);
 */
class Channel {
  constructor(name, noInnerEvents) {
    this._listeners = [];
    this._mute = false;
    this._accumulate = false;
    this._accumulatedEvents = [];
    this._name = name || '';
    this._noInnerEvents = Boolean(noInnerEvents);
    if (!noInnerEvents) {
      innerEvents.forEach(eventName => this[eventName] = new Channel(eventName, true));
    }
  }

  /**
   * Add listener for event
   * @param {Function} callback
   * @param {Object} [context]
   */
  addListener(callback, context) {
    this._pushListener(callback, context, false);
  }

  /**
   * Add once listener for event
   * @param {Function} callback
   * @param {Object} [context]
   */
  addOnceListener(callback, context) {
    this._pushListener(callback, context, true);
  }

  /**
   * Remove listener from event
   * @param {Function} callback
   * @param {Object} [context]
   */
  removeListener(callback, context) {
    this._ensureFunction(callback);
    const index = this._indexOfListener(callback, context);
    if (index >= 0) {
      this._spliceListener(index);
    }
  }

  /**
   * Remove all listeners from channel.
   */
  removeAllListeners() {
    while (this.hasListeners()) {
      this._spliceListener(0);
    }
  }

  /**
   * Is listener exist
   * @param {Function} callback
   * @param {Object} [context]
   * @returns {Boolean}
   */
  hasListener(callback, context) {
    this._ensureFunction(callback);
    return this._indexOfListener(callback, context) >= 0;
  }

  /**
   * Are there any listeners
   * @returns {Boolean}
   */
  hasListeners() {
    return this._listeners.length > 0;
  }

  /**
   * Call all listeners with specified params
   */
  dispatch(...args) {
    this._invokeListeners({args, async: false});
  }

  /**
   * Call all listeners with specified params asynchronously
   */
  dispatchAsync(...args) {
    this._invokeListeners({args, async: true});
  }

  /**
   * Mute channel
   * @param {Object} [options]
   * @param {Boolean} [options.accumulate] accumulate events and call listeners after .unmute()
   */
  mute(options = {}) {
    this._mute = true;
    if (options.accumulate) {
      this._accumulate = true;
    } else {
      this._accumulate = false;
      this._accumulatedEvents = [];
    }
  }

  /**
   * Unmute channel
   */
  unmute() {
    this._mute = false;
    if (this._accumulate) {
      this._dispatchAccumulated();
      this._accumulate = false;
    }
  }

  /**
   * @param {Object} options
   * @param {Array} options.args
   * @param {Boolean} [options.async]
   * @private
   */
  _invokeListeners(options = {args: [], async: false}) {
    if (!this._mute) {
      const listnersToInvoke = this._listeners.slice();
      listnersToInvoke.forEach(listener => {
        this._invokeListener(listener, options);
        if (listener.once) {
          this.removeListener(listener.callback, listener.context);
        }
      });
    } else if (this._accumulate) {
      this._accumulatedEvents.push(options);
    }
  }

  /**
   * @param {Object} listener
   * @param {Object} options
   * @param {Array} options.args
   * @param {Boolean} options.async
   * @private
   */
  _invokeListener(listener, options) {
    if (options.async) {
      setTimeout(() => listener.callback.apply(listener.context, options.args), 0);
    } else {
      listener.callback.apply(listener.context, options.args);
    }
  }

  /**
   * Ensure function
   * @param {Function} callback
   */
  _ensureFunction(callback) {
    if (typeof callback !== 'function') {
      throw new Error('Channel ' + this._name + ': listener is not a function');
    }
  }

  /**
   * Dispatch inner events when listener is added
   * @private
   */
  _dispatchInnerAddEvents() {
    if (!this._noInnerEvents) {
      this.onListenerAdded.dispatch.apply(this.onListenerAdded, arguments);
      if (this._listeners.length === 1) {
        this.onFirstListenerAdded.dispatch.apply(this.onFirstListenerAdded, arguments);
      }
    }
  }

  /**
   * Dispatch inner events when listener is removed
   * @private
   */
  _dispatchInnerRemoveEvents() {
    if (!this._noInnerEvents) {
      this.onListenerRemoved.dispatch.apply(this.onListenerRemoved, arguments);
      if (this._listeners.length === 0) {
        this.onLastListenerRemoved.dispatch.apply(this.onLastListenerRemoved, arguments);
      }
    }
  }

  /**
   * Find listener index
   * @param {Function} callback
   * @param {Object} [context]
   * @private
   */
  _indexOfListener(callback, context) {
    for (let i = 0; i < this._listeners.length; i++) {
      const listener = this._listeners[i];
      const equalCallbacks = listener.callback === callback;
      const emptyContexts = context === undefined && listener.context === undefined;
      const equalContexts = context === listener.context;
      if (equalCallbacks && (emptyContexts || equalContexts)) {
        return i;
      }
    }
  }

  /**
   * Dispatch accumulated events
   * @private
   */
  _dispatchAccumulated() {
    this._accumulatedEvents.forEach(options => this._invokeListeners(options));
    this._accumulatedEvents = [];
  }

  /**
   * Pushes listener
   * @param {Function} callback
   * @param {Object} context
   * @param {Boolean} once
   */
  _pushListener(callback, context, once) {
    this._ensureFunction(callback);
    this._listeners.push({callback, context, once});
    this._dispatchInnerAddEvents.apply(this, arguments);
  }

  /**
   * Splice listener under index
   * @param {Number} index
   */
  _spliceListener(index) {
    const listener = this._listeners[index];
    this._listeners.splice(index, 1);
    const args = [listener.callback];
    if (listener.context) {
      args.push(listener.context);
    }
    this._dispatchInnerRemoveEvents.apply(this, args);
  }
}

/**
 * Event emitter similar to Node.js [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter).
 * The main difference from single channel is that each method takes additional `event` argument.
 *
 * @example
 * import Channel from 'chnl';
 *
 * // create emitter
 * const emitter = new Channel.EventEmitter();
 * // listen 'myEvent'
 * emitter.on('myEvent', data => console.log(data));
 * // emit 'myEvent'
 * emitter.emit('myEvent', 'hello world!');
 */
class EventEmitter {
  constructor() {
    this._channels = new Map();
  }

  /**
   * Adds listener to specific event
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  addListener(event, callback, context) {
    this._getChannel(event).addListener(callback, context);
  }

  /**
   * Adds listener to specific event (alias to addListener)
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  on(event, callback, context) {
    this.addListener(event, callback, context);
  }

  /**
   * Adds once listener to specific event
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  addOnceListener(event, callback, context) {
    this._getChannel(event).addOnceListener(callback, context);
  }

  /**
   * Adds once listener to specific event (alias to addOnceListener)
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  once(event, callback, context) {
    this.addOnceListener(event, callback, context);
  }

  /**
   * Removes listener from specific event
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  removeListener(event, callback, context) {
    this._getChannel(event).removeListener(callback, context);
  }

  /**
   * Removes listener from specific event (alias to removeListener)
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   */
  off(event, callback, context) {
    this.removeListener(event, callback, context);
  }

  /**
   * Is listener exist for specific event
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   * @returns {Boolean}
   */
  hasListener(event, callback, context) {
    return this._getChannel(event).hasListener(callback, context);
  }

  /**
   * Is listener exist for specific event (alias to hasListener)
   *
   * @param {String} event
   * @param {Function} callback
   * @param {Object} [context]
   * @returns {Boolean}
   */
  has(event, callback, context) {
    return this.hasListener(event, callback, context);
  }

  /**
   * Are there any listeners for specific event
   *
   * @returns {Boolean}
   */
  hasListeners(event) {
    return this._getChannel(event).hasListeners();
  }

  /**
   * Call all listeners for specific event
   *
   * @param {String} event
   * @param {*} args
   */
  dispatch(event, ...args) {
    this._getChannel(event).dispatch(...args);
  }

  /**
   * Call all listeners for specific event
   *
   * @param {String} event
   * @param {*} args
   */
  emit(event, ...args) {
    this.dispatch(event, ...args);
  }

  /**
   * Returns channe by event name
   *
   * @param {String} event
   * @returns {Channel}
   * @private
   */
  _getChannel(event) {
    if (!this._channels.has(event)) {
      this._channels.set(event, new Channel(event));
    }
    return this._channels.get(event);
  }
}

/**
 * Subscription item
 * @private
 */
class SubscriptionItem {
  /**
   * Constructor
   *
   * @param {Object} params
   * @param {Object} params.channel
   * @param {String} [params.event]
   * @param {Function} params.listener
   */
  constructor(params) {
    this._params = params;
    this._isOn = false;
    this._assertParams();
  }

  /**
   * Turn on listener of channel
   */
  on() {
    if (!this._isOn) {
      const {channel} = this._params;
      const method = channel.addListener || channel.addEventListener || channel.on;
      this._applyMethod(method);
      this._isOn = true;
    }
  }

  /**
   * Turn off listener of channel
   */
  off() {
    if (this._isOn) {
      const {channel} = this._params;
      const method = channel.removeListener || channel.removeEventListener || channel.off;
      this._applyMethod(method);
      this._isOn = false;
    }
  }

  _applyMethod(method) {
    const {channel, event, listener} = this._params;
    const args = event ? [event, listener] : [listener];
    method.apply(channel, args);
  }

  _assertParams() {
    const {channel, event, listener} = this._params;
    if (!channel || typeof channel !== 'object') {
      throw new Error('Channel should be object');
    }
    if (event && typeof event !== 'string') {
      throw new Error('Event should be string');
    }
    if (!listener || typeof listener !== 'function') {
      throw new Error('Listener should be function');
    }
  }
}

/**
 * Utility class allowing dynamically attach/detach batch of listeners to event channels.
 *
 * @param {Array<{channel, event, listener}>} items
 *
 * @example
 * import Channel from 'chnl';
 * const subscription = new Channel.Subscription([
 *   {
 *     channel: chrome.tabs.onUpdated,
 *     listener: this._onTabUpdated.bind(this)
 *   }
 * ]);
 *
 * // attach listeners
 * subscription.on();
 * // detach listeners
 * subscription.off();
 */
class Subscription {
  constructor(items) {
    this._items = items.map(params => new SubscriptionItem(params));
  }

  /**
   * Turn on all listeners
   *
   * @returns {Subscription}
   */
  on() {
    this._items.forEach(item => item.on());
    return this;
  }

  /**
   * Turn off all listeners
   *
   * @returns {Subscription}
   */
  off() {
    this._items.forEach(item => item.off());
    return this;
  }
}

/**
 * Utility class that extends Subscription for using in ReactComponent - automatically attach/detach listeners
 * in `componentDidMount` / `componentWillUnmount`.
 *
 * @param {ReactComponent} component
 * @param {Array<{channel, event, listener}>} items
 *
 * @example
 * class Button extends React.Component {
 *   constructor() {
 *     super();
 *     new Channel.ReactSubscription(this, [
 *       {channel: onNewData, listener: this.handleNewData.bind(this)}
 *     ]);
 *   }
 * }
 *
 * // actually equals to (but with more boilerplate code):
 * class Button extends React.Component {
 *   constructor() {
 *     super();
 *     this.subscription = new Channel.Subscription([
 *       {channel: onNewData, listener: this.handleNewData.bind(this)}
 *     ]);
 *   }
 *   componentDidMount() {
 *     this.subscription.on();
 *   }
 *   componentWillUnmount() {
 *     this.subscription.off();
 *   }
 * }
 */
class ReactSubscription extends Subscription {
  constructor(component, items) {
    super(items);
    this._overrideComponentCallback(component, 'componentDidMount', 'on');
    this._overrideComponentCallback(component, 'componentWillUnmount', 'off');
  }

  /**
   * @param {ReactComponent} component
   * @param {String} callbackName
   * @param {String} methodName
   * @private
   */
  _overrideComponentCallback(component, callbackName, methodName) {
    const baseCallback = component[callbackName];
    component[callbackName] = (...args) => {
      this[methodName]();
      if (typeof baseCallback === 'function') {
        return baseCallback.apply(component, args);
      }
    };
  }
}

/**
 * Chnl entry point
 */

/**
 * @private
 */
const chnl = Channel;
chnl.EventEmitter = EventEmitter;
chnl.Subscription = Subscription;
chnl.ReactSubscription = ReactSubscription;

/*
 Can not export additional classes like:

 export {
 EventEmitter,
 Subscription,
 };

 because in that case babel's output is not compatible with pure commonjs
 See: http://stackoverflow.com/questions/33505992/babel-6-changes-how-it-exports-default
 */

module.exports = chnl;
